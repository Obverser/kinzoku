import subprocess
import os

from pycparser import c_parser, c_ast

# Preprocess the header file as required by the parser
text = subprocess.check_output(["clang", "-E", "./wgpu.h"]).decode("utf-8")
def condition(line: str) -> bool:
    return line.strip() != "typedef __builtin_va_list __darwin_va_list;"
lines = filter(condition, text.split("\n"))

# Parse the header
parser = c_parser.CParser()
ast = parser.parse("\n".join(lines), filename="wgpu.h")

# Generate internal function declarations
output_dir = "../Sources/Kinzoku/Generated"
os.makedirs(output_dir, exist_ok=True)
output_file = f"{output_dir}/Functions.swift"

class CodeGenException(Exception):
    def __init__(self, message):
        self.message = message

    def __repr__(self) -> str:
        return self.message

type_rewrites = {
    "void": "Void",
    "char": "CChar",
    "int": "Int32",
    "long": "Int64",
    "uint32_t": "UInt32",
    "uint64_t": "UInt64",
    "int32_t": "Int32",
    "int64_t": "Int64",
    "size_t": "Int",
    "_Bool": "Bool",
    "float": "Float",
    "UnsafeMutablePointer<Void>?": "UnsafeMutableRawPointer?"
}

def rewrite_type(name: str) -> str:
    if name in type_rewrites:
        return type_rewrites[name]
    else:
        return name

def type_to_swift_type(t) -> str:
    if type(t) == c_ast.TypeDecl:
        return rewrite_type(t.type.names[0])
    elif type(t) == c_ast.PtrDecl:
        inner = rewrite_type(t.type.type.names[0])
        return rewrite_type("UnsafeMutablePointer<" + inner + ">?")
    else:
        raise CodeGenException("Unable to convert C type to Swift Type: " + t)

swift_funcs = []
for decl in ast.ext:
    if decl.name == "wgpuSurfaceGetCapabilities":
        # This function has a parameter of type WGPUSurfaceCapabilities (which Swift can't find, and
        # neither can I). Therefore we skip it.
        continue
    elif type(decl.type) == c_ast.FuncDecl:
        func_decl = decl.type

        swift_params = []
        for param in func_decl.args.params:
            param_type = type_to_swift_type(param.type)
            if param_type != "Void":
                swift_params.append((param.name, param_type))

        swift_return = type_to_swift_type(func_decl.type)


        swift_funcs.append((decl.name, swift_params, swift_return))

lines = [
    "// This file is automatically generated from wgpu's C headers. Do not edit it directly.",
    "private let loader = Loader()"
]
for (name, params, return_type) in swift_funcs:
    params = ", ".join(map(lambda x: x[1], params))
    line = f'let {name}: @convention(c) ({params}) -> {return_type} = loader.load("{name}")'
    lines.append(line)

with open(output_file, "w") as f:
    f.write("\n".join(lines))

# Generate types
def stringify(node) -> str:
    if type(node) == c_ast.Constant:
        return node.value
    elif type(node) == c_ast.ID:
        return node.name
    elif type(node) == c_ast.BinaryOp:
        left = stringify(node.left)
        right = stringify(node.right)
        return f"{left} {node.op} {right}"
    else:
        raise CodeGenException(f"Failed to stringify a node: '{node}'")

# TODO: Fix enum generation for KZInstanceBackend (have to evaluate constants to obtain equivalent
# literals)

def detect_casing(identifier: str) -> str:
    """Returns the most likely casing scheme used by a given identifier.
    A very rough heuristic method is used to identify the casing. The
    algorithm can be updated in future if it is not sophisticated
    enough.
    """

    all_caps = True
    for c in identifier:
        if c.isalpha() and c.islower():
            all_caps = False
            break
    if all_caps:
        return "screaming_snake"
    elif identifier[0].isupper():
        return "upper_camel"
    elif identifier[0].islower():
        return "snake" if "_" in identifier else "lower_camel"
    else:
        return "unknown"

swift_keywords = ["internal", "default", "repeat"]
replacements = {
    "src": "source",
    "dst": "destination"
}
acronyms = [
    "CPU",
    "GPU",
    "GL"
]

def swiftify_identifier(identifier: str) -> str:
    if identifier in acronyms:
        return identifier.lower()

    casing = detect_casing(identifier)
    parts = []
    if casing == "snake" or casing == "screaming_snake":
        parts = identifier.lower().split("_")
        parts = [part.lower() for part in parts if part != ""]
    elif casing == "lower_camel" or casing == "upper_camel":
        lower_camel = identifier[0].lower() + identifier[1:]
        parts = []
        current_part = ""
        for c in lower_camel:
            if c.isupper():
                parts.append(current_part)
                current_part = c.lower()
            else:
                current_part += c.lower()
        if current_part != "":
            parts.append(current_part)
    else:
        parts = [identifier]

    for (i, part) in enumerate(parts):
        parts[i] = replacements.get(part, part)
        if part in replacements:
            parts[i] = replacements[part]

    for (i, part) in enumerate(parts[1:]):
        parts[i + 1] = part[0].upper() + part[1:]

    swift_identifier = "".join(parts)
    if swift_identifier in swift_keywords:
        swift_identifier = f"`{swift_identifier}`"
    elif not swift_identifier[0].isalpha():
        swift_identifier = f"_{swift_identifier}"
    return swift_identifier

swift_enums = []
swift_types = []
for decl in ast.ext:
    if type(decl) == c_ast.Typedef and decl.name.startswith("WGPU"):
        if decl.name == "WGPUInstanceBackend":
            continue

        if type(decl.type.type) == c_ast.Enum:
            cases = []
            enum_raw_type = "UInt32"
            prefixLength = len(decl.name) + 1
            for enum_case in decl.type.type.values.enumerators:
                case_name = enum_case.name[prefixLength:]
                case_name = swiftify_identifier(case_name)

                value = stringify(enum_case.value)
                cases.append((case_name, value))
            swift_enums.append((decl.name, enum_raw_type, cases))
        else:
            methods = []
            prefix = "wgpu" + decl.name[4:]
            for func in swift_funcs:
                if func[0].startswith(prefix):
                    func_name, params, return_type = func
                    method_name = func_name[len(prefix):]
                    method_name = swiftify_identifier(method_name)
                    if params[0][1] != decl.name:
                        # Verify match
                        continue
                    methods.append((method_name, func_name, params[1:], return_type))
            swift_types.append((decl.name, methods))

output_file = f"{output_dir}/Enums.swift"
lines = [
    "// This file is automatically generated from wgpu's C headers. Do not edit it directly.",
    "private let loader = Loader()"
]
for name, raw_type, cases in swift_enums:
    swift_name = "KZ" + name[4:]
    lines.append(f"public enum {swift_name}: {raw_type} {{")
    seen_values: dict[str, str] = {}
    duplicates: list[tuple[str, str]] = []

    for case_name, value in cases:
        if value in seen_values:
            original_case = seen_values[value]
            duplicates.append((case_name, original_case))
            continue
        seen_values[value] = case_name
        lines.append(f"    case {case_name} = {value}")

    for shadow_case, original_case in duplicates:
        lines.append(f"")
        lines.append(f"    var {shadow_case}: {swift_name} {{")
        lines.append(f"        return .{original_case}")
        lines.append(f"    }}")

    lines.append(f"")
    lines.append(f"    var c: {name} {{")
    lines.append(f"        return {name}(rawValue: rawValue)")
    lines.append(f"    }}")
    lines.append(f"")
    lines.append(f"    init(_ c: {name}) {{")
    lines.append(f"         self = {swift_name}(rawValue: c.rawValue)!")
    lines.append(f"    }}")
    lines.append(f"}}")

with open(output_file, "w") as f:
    f.write("\n".join(lines))

output_file = f"{output_dir}/Types.swift"
lines = [
    "// This file is automatically generated from wgpu's C headers. Do not edit it directly.",
    "private let loader = Loader()"
]
for name, methods in swift_types:
    if name != "WGPUBuffer" and name != "WGPUCommandBuffer":
        continue

    swift_name = "KZ" + name[4:]
    lines.append(f"public final class {swift_name} {{")
    lines.append(f"    var c: {name}")
    lines.append(f"")
    lines.append(f"    init(_ c: {name}) {{")
    lines.append(f"        self.c = c")
    lines.append(f"    }}")
    for method_name, func_name, params, return_type in methods:
        if method_name == "drop" and name == "WGPUCommandBuffer":
            # At the moment memory management is dodgy and WGPUCommandBuffer shouldn't be
            # auto-dropped
            continue

        lines.append(f"")

        params_str = ", ".join(f"{name}: {param_type}" for (name, param_type) in params)

        arg_names = ["c"] + [name for (name, _) in params]
        args = ", ".join(arg_names)

        type_parameters = ""
        should_cast = False
        if return_type == "UnsafeMutableRawPointer?":
            type_parameters = "<T>"
            return_type = "UnsafeMutablePointer<T>?"
            should_cast = True

        if method_name == "drop":
            lines.append(f"    deinit {{")
        else:
            lines.append(f"    public func {method_name}{type_parameters}({params_str}) -> {return_type} {{")

        if should_cast:
            lines.append(f"        let result = {func_name}({args})")
            lines.append(f"        return result?.bindMemory(to: T.self, capacity: 1)")
        else:
            lines.append(f"        return {func_name}({args})")

        lines.append(f"    }}")
    lines.append(f"}}")

with open(output_file, "w") as f:
    f.write("\n".join(lines))
